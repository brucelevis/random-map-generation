#
#  A Procedural Dungeon Generator based on ideas from a article by
#  Bob Nystrom.
#    See http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/
#
#  William Cheung,  4/7/2016
#


#__________________________________________________________________________
# Utility classes


class Pair:
    def __init__(self, first, second):
        self.first = first
        self.second = second


class Rect:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def overlaps(self, other):
        x1 = max(self.x, other.x)
        x2 = min(self.x + self.width, other.x + other.width)
        y1 = max(self.y, other.y)
        y2 = min(self.y + self.height, other.y + other.height)
        return x1 <= x2 and y1 <= y2

    def area(self):
        return self.width * self.height


#__________________________________________________________________________
# class Graph
#   we use the class to solve a certain kind of shortest path problem
#   in which:
#     * vertices have weights and the weights of edges are 0s
#     * the cost of a path is the sum of the costs of the vertices
#       encountered on the path.
#


class Graph:
    # we assume that nodes are numbered from 0
    def __init__(self, node_weights, infinity=100000000):
        self._node_weights = node_weights[:]
        self._nnodes = len(self._node_weights)
        self._infinity = infinity
        self._dist = [[infinity] * self._nnodes for i in xrange(self._nnodes)]
        # _next[u][v]: u's next vertice on the shortest path from u to v;
        #              for path reconstruction
        self._next = [[-1] * self._nnodes for i in xrange(self._nnodes)]

    def add_edge(self, u, v):
        # we initialize the weight of an edge to the sum of weights of its
        # two endpoint vertices
        self._dist[u][v] = self._node_weights[u] + self._node_weights[v]
        self._next[u][v] = v

    def floyd_warshall(self):
        # implementation of Floyd-Warshall algorithm 
        for i in xrange(self._nnodes):
            for j in xrange(self._nnodes):
                for k in xrange(self._nnodes):
                    d = self._dist[i][k] + self._dist[k][j] - self._node_weights[k]
                    if d < self._dist[i][j]:
                        self._dist[i][j] = d
                        self._next[i][j] = self._next[i][k]

    def max_sps(self):
        # returns a list of Pair(u, v)
        #   { (u, v) | _dist[u][v] == max{_dist[x][y]} }
        max_ = -1
        for i in xrange(self._nnodes):
            for j in xrange(self._nnodes):
                if self._dist[i][j] != self._infinity and \
                   self._dist[i][j] > max_:
                    max_ = self._dist[i][j]

        ret = []
        for i in xrange(self._nnodes):
            for j in xrange(self._nnodes):
                if self._dist[i][j] == max_:
                    ret.append(Pair(i, j))
        return ret

    def shortest_path(self, u, v):
        # return the length of the shortest path of from u to v and the list
        # of nodes along the path
        if self._next[u][v] == -1:
            return self._infinity, []
        dist = self._dist[u][v]
        path = [u]
        while u != v:
            u = self._next[u][v]
            path.append(u)
        return dist, path

#__________________________________________________________________________
# class Dungeon
#
#   In the implementation, a dungeon is constructed as a two-dimensional
#   matrix of integers, each representing one tile. Within an integer,
#   each bit indicates a different state, such as 0x01 for tiles in rooms,
#   0x02 for solid rocks and 0x04 for tiles in corridors. Rooms and
#   corridors always fall along odd-numbered columns and rows, and rooms
#   are always odd numbers in width and height.
#
#   Rooms are placed randomly. If a room does not collide with other rooms,
#   then the room will be marked out in the matrix.
#
#   The corridor generator is a simple recursive algorithm with a few
#   quirks. Corridors are generated by shuffling the list of directions
#   randomly. Corridors continue in these directions in a depth-first
#   manner.
#
#   After marking out rooms and corridors, the generator calculates all
#   possible positions where it may place doors. Next, the generator use
#   a spanning tree algorithm to mark out doors in the matrix.
#
#   The generator removes all dead ends in the matrix, which may make the
#   dungeon more fun to play.
#
#   POI(path of interest) Finding:
#     POI is a path which should be sufficiently long and a player has a
#     big interest to travel on. The generator provides a method for
#     finding a POI in the generated dungeon. 
#
#     We use a graph derived from a dungeon to calculate POI.
#     In the derived graph:
#       Nodes are rooms, doors, branching points or sets of continuous
#         corridors between doors and branching points.
#       Each node has a predefined weight value (aka cost).
#       Every pair of nodes that are adjacent are connected in the graph,
#         say there is an edge between them.
#       Length of a path is the sum of weights of nodes on the path.
#
#     Then POI is defined as a longest path among shortest paths between
#       any pairs of nodes in the graph.
#

class Dungeon:

    TILE_ROOM = 0x01
    TILE_ROCK = 0x02
    TILE_CORR = 0x04  # corridors
    TILE_DOOR = 0x08
    TILE_MARK = 0x10

    def __init__(self):
        self._rep = None    # representation of the map
        self._id = None     # id of each tile on the map
        self._width = 51    # witdh of the map
        self._height = 51   # height of the map
        self._attempts = 50 # number of attempts to place rooms
        self._room_wrange = Pair(3, 6)  # [) range of witdh of rooms
        self._room_hrange = Pair(3, 6)  # [) range of height of rooms 
        self._rooms = None

    def set_geometry(self, width, height):
        # the width and the height of the map _MUST_ be odd
        assert width % 2 == 1
        assert height % 2 == 1
        assert width <= 201
        assert height <= 201

        self._width = width
        self._height = height

        # we prevent our program from a stack overflow in case of large
        # recursion depths
        import sys
        limit = max(self._width * self._height, sys.getrecursionlimit())
        sys.setrecursionlimit(limit)

    def set_attempts(self, attempts):
        self._attempts = attempts

    def set_roomsize(self, w_range, h_range):
        # set the range of room size
        assert w_range.first % 2 != 0
        assert w_range.first <= w_range.second
        assert w_range.first % 2 != 0
        assert h_range.first <= h_range.second
        self._room_wrange = Pair(w_range.first, w_range.second + 1)
        self._roon_hrange = Pair(h_range.first, h_range.second + 1)

    def get_rep(self):
        return self._rep

    def print_(self):
        if not self._rep:
            raise Exception('You _SHOULD_ call generate() first')

        def __symbol(type):
            if type == Dungeon.TILE_MARK:
                return '.'
            if type == Dungeon.TILE_ROOM:
                return '+'
            if type == Dungeon.TILE_CORR:
                return ' '
            if type == Dungeon.TILE_ROCK:
                return '#'
            if type == Dungeon.TILE_DOOR:
                return 'x'
            raise Exception('Undefined dungeon tile')

        output = ''
        for y in xrange(self._height):
            for x in xrange(self._width):
                output += __symbol(self._rep[y][x])
            output += '\n'

        print output

    def generate(self):
        # generate a dungeon
        self._rep = [[Dungeon.TILE_ROCK] * self._width for i in xrange(self._height)]
        self._id = [[0] * self._width for i in xrange(self._height)]

        # place a bunch of random non-overlapping rooms on the map
        self._place_rooms()

        # fill in the remaining solid regions with mazes
        # (replace rocks with corridors)
        self._place_corrs() 

        # use doors to connect each of the mazes and rooms to their neighbors
        self._place_doors()

        # remove all of the dead ends. a dead end is a corridor position or a
        # door position with 3 rock neighbors
        self._remove_dead_ends()

    def _place_rooms(self):
        
        #  generate a bunch of randomly located, non-overlapping rooms
        rooms = []
        for i in xrange(self._attempts):
            room = self._rand_room(Pair(1, self._width - 1),
                             Pair(1, self._height - 1),
                             self._room_wrange,
                             self._room_hrange)
            if not self._valid_room(room, rooms):
                continue
            rooms.append(room)

        print 'Number of Rooms: %d' % len(rooms)
        '''
        print 'Rooms:'
        for room in rooms:
            print '%2d %2d %2d %2d' % (room.y, room.x, room.height, room.width)
        '''

        # we use room ids to index into self._rooms; room ids are integers no
        # less than 1
        room_id_base = 1
        self._rooms = [None] * room_id_base
        for i, room in enumerate(rooms):
            room_id = i + room_id_base
            
            # draw the room on the map 
            for y in xrange(room.y, room.y + room.height):
                for x in xrange(room.x, room.x + room.width):
                    self._rep[y][x] = Dungeon.TILE_ROOM
                    self._id[y][x] = room_id
                    
            self._rooms.append(room)

    def _rand_room(self, x_range, y_range, w_range, h_range):
        # generate a randomly placed and randomly sized room
        from random import randint

        def __filter_odds(rg):
            return [x for x in xrange(rg.first, rg.second) if x % 2 != 0]

        # use odd sizes and positions for rooms so they can be aligned with
        # the mazes
        xs, ys = __filter_odds(x_range), __filter_odds(y_range)
        ws, hs = __filter_odds(w_range), __filter_odds(h_range)

        return Rect(xs[randint(0, len(xs)-1)],
                    ys[randint(0, len(ys)-1)],
                    ws[randint(0, len(ws)-1)],
                    hs[randint(0, len(hs)-1)])

    def _valid_room(self, room, rooms):

        # test if the position is out of range
        if room.x + room.width > self._width - 1:
            return False
        if room.y + room.height > self._height - 1:
            return False

        # test if the room overlaps other rooms already placed
        for other in rooms:
            if room.overlaps(other):
                return False
        return True

    def _place_corrs(self):
        # generate mazes and place them
        maze_id = len(self._rooms)
        for y in xrange(1, self._height - 1):
            for x in xrange(1, self._width - 1):
                if self._aux_place_corrs(None, Pair(x, y), maze_id):
                    maze_id += 1

    def _aux_place_corrs(self, prev, curr, id):
        if not self._valid_corr_pos(prev, curr):
            return False
        x, y = curr.first, curr.second
        self._rep[y][x] = Dungeon.TILE_CORR
        self._id[y][x] = id

        #  after placing a corridor, there are four cases facing us:
        # 
        #      ? ? *   * C *   * ? ?   ? ? ?
        #      ? x C   ? x ?   C x ?   ? x ?
        #      ? ? *   ? ? ?   * ? ?   * C *
        #
        #      ? - positions that will be tested
        #      C - position where we placed a corridor just now
        #      x - candidate position for the next corridor
        #      * - positions we don't care
        # 
        #  if all positions marked by '?'s are rocks (TILE_ROCKs) and
        #  position 'x' is also a rock, we can place the next corridor
        #  at 'x' and continue depth-first searching
        #

        rx1, rx2 = [-2, 1, -1, -1], [0, 3, 2, 2]
        ry1, ry2 = [-1, -1, -2, 1], [2, 2, 0, 3]
        dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]

        from random import shuffle
        directions = [0, 1, 2, 3]
        shuffle(directions)  # shuffling the directions
        for d in directions:
            if self._count_rocks(Pair(x + rx1[d], x + rx2[d]),
                                 Pair(y + ry1[d], y + ry2[d])) == 6:
                self._aux_place_corrs(curr, Pair(x + dx[d], y + dy[d]), id)
        return True

    def _valid_pos(self, x, y):
        if x < 1 or x >= self._width - 1:
            return False
        if y < 1 or y >= self._height - 1:
            return False
        return True

    def _valid_corr_pos(self, prev, curr):
        x, y = curr.first, curr.second
        if not self._valid_pos(x, y):
            return False
        if self._rep[y][x] != Dungeon.TILE_ROCK:
            return False
        # we start BFS from a rock surrounded by 8 rocks
        if prev is None and self._count_surr_rocks(x, y) != 8:
            return False
        return True

    def _count_surr_rocks(self, x, y):
        # count surrounding rocks of a position
        count = 0
        for dy in xrange(-1, 2):
            for dx in xrange(-1, 2):
                if dx == 0 and dy == 0:
                    continue
                if self._rep[y+dy][x+dx] == Dungeon.TILE_ROCK:
                    count += 1
        return count

    def _count_rocks(self, x_range, y_range):
        # count rocks in a rectangular region
        count = 0
        for y in xrange(y_range.first, y_range.second):
            for x in xrange(x_range.first, x_range.second):
                if x < 0 or x >= self._width or y < 0 or y >= self._height:
                    continue
                if self._rep[y][x] == Dungeon.TILE_ROCK:
                    count += 1
        return count

    def _place_doors(self):

        # find all connectors. connectors are tiles that are:
        #  1. solid rock
        #  2. adjacent to two rooms or a room and a corridor.
        
        connectors = []
        for y in xrange(1, self._height-1):
            for x in xrange(1, self._width-1):
                if self._rep[y][x] != Dungeon.TILE_ROCK:
                    continue
                comp_type1 = Dungeon.TILE_CORR | Dungeon.TILE_ROOM
                comp_type2 = Dungeon.TILE_ROOM
                comp1 = self._rep[y][x-1] | self._rep[y][x+1]
                comp2 = self._rep[y-1][x] | self._rep[y+1][x]
                if comp1 == comp_type1 or comp1 == comp_type2:
                    connectors.append((x, y, self._id[y][x-1], self._id[y][x+1]))
                elif comp2 == comp_type1 or comp2 == comp_type2:
                    connectors.append((x, y, self._id[y-1][x], self._id[y+1][x]))

        # the basic idea for placing doors is placing doors at connector
        # positions that help form a spanning tree in which nodes are rooms
        # and mazes.
        self._do_place_doors(connectors)

    def _do_place_doors(self, connectors):

        # we use union-find data structure to construct a spanning tree
        max_id = max([max(row) for row in self._id])
        L = [i for i in range(0, max_id + 1)]

        def __union(x, y):
            L[__find(x)] = __find(y)

        def __find(x):
            if L[x] != x:
                L[x] = __find(L[x])
            return L[x]

        from random import random
        from random import shuffle

        def __place_door(x, y, id1, id2):
            if __find(id1) == __find(id2):
                # we allow two or more doors between two regions with a slight
                # chance 
                if random() < 0.01 and self._count_neighbor_doors(x, y) == 0:
                    self._rep[y][x] = Dungeon.TILE_DOOR
            else:
                __union(id1, id2)
                self._rep[y][x] = Dungeon.TILE_DOOR

        # shuffling for randomness
        shuffle(connectors)
        for conn in connectors:
            __place_door(*conn)

    def _count_neighbor_doors(self, x, y):
        # count doors in neighbor positions
        count = 0
        if self._rep[y-1][x] == Dungeon.TILE_DOOR:
            count += 1
        if self._rep[y+1][x] == Dungeon.TILE_DOOR:
            count += 1
        if self._rep[y][x-1] == Dungeon.TILE_DOOR:
            count += 1
        if self._rep[y][x+1] == Dungeon.TILE_DOOR:
            count += 1
        return count

    def _remove_dead_ends(self):
        # remove all dead ends
        for y in xrange(1, self._height - 1):
            for x in xrange(1, self._width - 1):
                self._aux_remove_dead_ends(x, y)

    def _aux_remove_dead_ends(self, x, y):
        if not self._is_dead_end(x, y):
            return
        self._rep[y][x] = Dungeon.TILE_ROCK
        self._id[y][x] = 0
        self._aux_remove_dead_ends(x-1, y)
        self._aux_remove_dead_ends(x+1, y)
        self._aux_remove_dead_ends(x, y-1)
        self._aux_remove_dead_ends(x, y+1)

    def _is_dead_end(self, x, y):
        if not self._valid_pos(x, y):
            return False
        if self._rep[y][x] != Dungeon.TILE_CORR and \
                self._rep[y][x] != Dungeon.TILE_DOOR:
            return False
        if self._count_neighbors_not_rock(x, y) != 1:
            return False
        return True

    def _count_neighbors_not_rock(self, x, y):
        count = 0
        if self._rep[y-1][x] != Dungeon.TILE_ROCK:
            count += 1
        if self._rep[y+1][x] != Dungeon.TILE_ROCK:
            count += 1
        if self._rep[y][x-1] != Dungeon.TILE_ROCK:
            count += 1
        if self._rep[y][x+1] != Dungeon.TILE_ROCK:
            count += 1
        return count
    
    #______________________________________________________________________
    # class for POI (Path Of Interest) finding
    class _Node:

        # types of nodes:
        TYPE_ROOM = 0x01   # room
        TYPE_DOOR = 0x02   # door
        TYPE_BRCH = 0x04   # branching point
        TYPE_CORR = 0x08   # corridor

        def __init__(self, type, weight, path):
            self.type = type
            self.weight = weight
            self.path = path[:]

        def __eq__(self, other):
            return set(self.path) == set(other.path)

        def __str__(self):
            return 'type %02x, weight %2d, pos (%2d, %2d)' % (self.type,
                                                              self.weight,
                                                              self.path[0].second, self.path[0].first)
    #_____________________________________________________________________
        
    def find_poi(self):
        if not self._rep:
            raise Exception('This call _MUST_ come after generate()')

        print 'Find POI'

        nodes, edges = [], []
        # tile (x, y) belongs to node whose id is visited[y][x] 
        visited = [[-1] * self._width for i in xrange(self._height)]
        for y in xrange(1, self._height - 1):
            for x in xrange(1, self._width - 1):
                if visited[y][x] == -1 and self._rep[y][x] == self.TILE_DOOR:
                    self._collect_graph_info(x, y, -1, nodes, edges, visited)

        print 'Number of nodes:', len(nodes)
        '''
        print 'Nodes:'
        for i, node in enumerate(nodes):
            print '%3d %s' % (i+1, str(node))
        '''
        '''
        print 'Node Map:'
        node_map = [[0] * self._width for i in xrange(self._height)]
        for i, node in enumerate(nodes):
            for p in node.path:
                x, y = p.first, p.second
                node_map[y][x] = i + 1

        output = ''
        for y in xrange(self._height):
            for x in xrange(self._width):
                output += '%2d ' % node_map[y][x]
            output += '\n'
        print output

        print 'Edges:'
        for edge in edges:
            print '%2d -> %2d' % (edge.first+1, edge.second+1)
        '''
        # graph initialization
        node_weights = [node.weight for node in nodes]
        graph = Graph(node_weights)
        for edge in edges:
            u, v = edge.first, edge.second
            graph.add_edge(u, v)
            graph.add_edge(v, u)

        # run Floyd-Warshall algorithm
        graph.floyd_warshall()

        # get endpoints of the longest paths among shortest paths of all pairs
        pairs = graph.max_sps()

        assert len(pairs) > 0

        # we select one 'longest path' and mark it out on the map
        dist, path = graph.shortest_path(pairs[0].first, pairs[0].second)
        print 'Dist:', dist
        for u in path:
            node = nodes[u]
            # print node
            if node.type == node.TYPE_CORR or node.type == node.TYPE_BRCH:
                for p in node.path:
                    x, y = p.first, p.second
                    self._rep[y][x] = Dungeon.TILE_MARK

    def _collect_graph_info(self, x, y, prev_id, nodes, edges, visited):
        if not self._valid_pos(x, y):
            return
        if visited[y][x] != -1:  # we encounter a position visited
            if prev_id != -1 and prev_id != visited[y][x]:
                # edge: prev_id -> visited[y][x] 
                edges.append(Pair(prev_id, visited[y][x]))
            return

        curr_id = len(nodes)
        if prev_id != -1:
            # we come from node prev_id to node curr_id, so there must
            # be an edge between node prev_id and node curr_id
            edges.append(Pair(prev_id, curr_id))

        if self._rep[y][x] == self.TILE_ROOM:
            # we encounter a room node 
            room_id = self._id[y][x]
            room = self._rooms[room_id]
            nodes.append(Dungeon._Node(Dungeon._Node.TYPE_ROOM, room.area(), [Pair(room.x, room.y)]))

            doors = self._find_doors_of_room(x, y, curr_id, visited)
            # we select a door of the room and continue our traversal
            for door in doors:
                d_x, d_y = door.first, door.second
                self._collect_graph_info(d_x, d_y, curr_id, nodes, edges, visited)

        elif self._rep[y][x] == self.TILE_DOOR:
            # we encounter a door node
            nodes.append(Dungeon._Node(Dungeon._Node.TYPE_DOOR, 1, [Pair(x, y)]))
            visited[y][x] = curr_id

            self._aux_collect_graph_info(x, y, curr_id, nodes, edges, visited)

        elif self._is_branching_point(x, y):
            # we encounter a branching point. a branching point a corridor
            # position where there are more than three possible directions
            # in which we can continue to walk
            nodes.append(Dungeon._Node(Dungeon._Node.TYPE_BRCH, 1, [Pair(x, y)]))
            visited[y][x] = curr_id
            
            self._aux_collect_graph_info(x, y, curr_id, nodes, edges, visited)

        elif self._rep[y][x] == self.TILE_CORR:
            # we encounter a region of corridors
            corrs = self._collect_corrs(x, y, curr_id, visited)
            assert len(corrs) > 0
            nodes.append(Dungeon._Node(Dungeon._Node.TYPE_CORR, len(corrs), corrs))

            last_x, last_y = corrs[-1].first, corrs[-1].second
            self._aux_collect_graph_info(last_x, last_y, curr_id, nodes, edges, visited)

    def _aux_collect_graph_info(self, x, y, curr_id, nodes, edges, visited):
        if self._rep[y-1][x] != self.TILE_ROCK:
            self._collect_graph_info(x, y-1, curr_id, nodes, edges, visited)
        if self._rep[y+1][x] != self.TILE_ROCK:
            self._collect_graph_info(x, y+1, curr_id, nodes, edges, visited)
        if self._rep[y][x-1] != self.TILE_ROCK:
            self._collect_graph_info(x-1, y, curr_id, nodes, edges, visited)
        if self._rep[y][x+1] != self.TILE_ROCK:
            self._collect_graph_info(x+1, y, curr_id, nodes, edges, visited)

    def _is_branching_point(self, x, y):
        if not self._valid_pos(x, y):
            return False
        if self._rep[y][x] != Dungeon.TILE_CORR:
            return False
        if self._count_neighbors_not_rock(x, y) < 3:
            return False
        return True

    def _find_doors_of_room(self, x, y, curr_id, visited):
        if not self._valid_pos(x, y):
            return []
        if visited[y][x] != -1:
            return []
        if self._rep[y][x] == self.TILE_ROCK:
            return []
        if self._rep[y][x] == self.TILE_DOOR:
            return [Pair(x, y)]

        visited[y][x] = curr_id
        ret = []
        ret += self._find_doors_of_room(x-1, y, curr_id, visited)
        ret += self._find_doors_of_room(x+1, y, curr_id, visited)
        ret += self._find_doors_of_room(x, y-1, curr_id, visited)
        ret += self._find_doors_of_room(x, y+1, curr_id, visited)
        return ret

    def _collect_corrs(self, x, y, curr_id, visited):
        if not self._valid_pos(x, y):
            return []
        if visited[y][x] != -1:
            return []
        if self._rep[y][x] != Dungeon.TILE_CORR:
            return []
        if self._is_branching_point(x, y):
            return []

        visited[y][x] = curr_id
        ret = [Pair(x, y)]
        ret += self._collect_corrs(x-1, y, curr_id, visited)
        ret += self._collect_corrs(x+1, y, curr_id, visited)
        ret += self._collect_corrs(x, y-1, curr_id, visited)
        ret += self._collect_corrs(x, y+1, curr_id, visited)
        return ret

#__________________________________________________________________________
# Code for testing

def main():
    dungeon = Dungeon()
    dungeon.set_geometry(81, 31)
    dungeon.set_attempts(100)
    dungeon.set_roomsize(Pair(3, 7), Pair(3, 7))
    dungeon.generate()
    dungeon.print_()
    dungeon.find_poi()
    dungeon.print_()


if __name__ == '__main__':
    main()
